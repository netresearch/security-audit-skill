# CVE-Derived Vulnerability Patterns

These patterns were identified through analysis of real-world CVEs in WordPress, Drupal,
Laravel, Symfony, TYPO3, and other PHP projects. Each pattern documents a specific
vulnerability class with its CWE mapping, real-world impact, vulnerable and secure code
examples, framework-specific mitigations, and grep-based detection patterns.

---

## Critical Priority

### 1. PHP Type Juggling (CWE-843)

#### Overview

PHP loose comparison (`==`) applies type coercion that produces unexpected equality
results. The string `"0e123"` is treated as scientific notation (zero), so
`"0e123" == "0"` evaluates to `true`. Similarly, `"0" == false` is `true`, and
`"" == null` is `true`. When loose comparison is used in authentication logic,
attackers can bypass token validation, password checks, and access controls.

Real-world CVEs exploiting type juggling include WordPress authentication bypass
and Drupal password reset vulnerabilities.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// Loose comparison allows type juggling -- attacker sends "0" to match
// any stored token that starts with "0e" followed by digits (e.g., "0e462097431906509019562988736854")
if ($_POST['token'] == $storedToken) {
    grantAccess();
}

// VULNERABLE - DO NOT USE
// Password reset token verification with loose comparison
function verifyResetToken(string $email, string $token): bool
{
    $stored = getResetTokenForEmail($email);
    // md5() of certain inputs produces "0e..." hashes -- attacker sends "0"
    return ($token == $stored);
}

// VULNERABLE - DO NOT USE
// Switch uses loose comparison by default
switch ($_GET['action']) {
    case 0:    // Matches ANY string that does not start with a digit
        deleteAll();
        break;
}

// VULNERABLE - DO NOT USE
// in_array without strict flag uses loose comparison
$allowedRoles = [0, 'admin', 'editor'];
if (in_array($_POST['role'], $allowedRoles)) {
    // "anything" == 0 is true in loose comparison, so any string matches
    assignRole($_POST['role']);
}
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: hash_equals() performs timing-safe strict byte comparison
if (hash_equals($storedToken, $_POST['token'])) {
    grantAccess();
}

// SECURE: Strict comparison prevents type juggling
function verifyResetToken(string $email, string $token): bool
{
    $stored = getResetTokenForEmail($email);
    return hash_equals($stored, $token);
}

// SECURE: Use match expression (strict comparison) instead of switch
match ($_GET['action']) {
    'delete' => deleteAll(),
    'list' => listItems(),
    default => throw new \InvalidArgumentException('Unknown action'),
};

// SECURE: in_array with strict flag (third parameter)
$allowedRoles = ['admin', 'editor', 'viewer'];
if (in_array($_POST['role'], $allowedRoles, true)) {
    assignRole($_POST['role']);
}
```

#### Framework Patterns

Symfony, Laravel, and TYPO3 all use `hash_equals()` internally for CSRF and
remember-me token validation. When writing custom token verification, always
use `hash_equals()` rather than any comparison operator.

#### Detection Patterns

```bash
# Loose comparison with superglobals (high priority)
grep -rn '==\s*\$_\(GET\|POST\|COOKIE\|REQUEST\)' --include="*.php" src/ Classes/

# Loose comparison with token/hash/password variables
grep -rn '==\s*\$.*token\|==\s*\$.*hash\|==\s*\$.*pass' --include="*.php" src/ Classes/

# in_array without strict flag
grep -rn 'in_array\s*(' --include="*.php" src/ Classes/ | grep -v 'true\s*)'

# switch on user input (uses loose comparison)
grep -rn 'switch\s*(\$_\(GET\|POST\|REQUEST\)' --include="*.php" src/ Classes/
```

---

### 2. PHAR Deserialization (CWE-502)

#### Overview

The `phar://` stream wrapper triggers PHP object deserialization when any file
operation is performed on a PHAR archive. Functions like `file_exists()`,
`is_dir()`, `filesize()`, `fopen()`, and dozens more will deserialize the PHAR
metadata, invoking `__destruct()` and `__wakeup()` magic methods on any objects
embedded in it. Attackers upload a polyglot file (valid JPEG that is also a valid
PHAR) and then trigger deserialization via `file_exists('phar://uploads/avatar.jpg')`.

Real-world CVEs include WordPress PHPMailer exploitation and Drupal file operation
chains.

See also: `deserialization-prevention.md` for comprehensive phar:// and
`unserialize()` coverage.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// file_exists() triggers PHAR metadata deserialization when path starts with phar://
function checkUploadedFile(string $path): bool
{
    return file_exists($path);  // If $path is "phar://uploads/evil.jpg", deserializes
}

// VULNERABLE - DO NOT USE
// Image processing with user-controlled path
function getImageSize(string $uploadedPath): array
{
    if (is_file($uploadedPath)) {  // Triggers deserialization
        return getimagesize($uploadedPath);  // Also triggers deserialization
    }
    return [0, 0];
}

// VULNERABLE - DO NOT USE
// Thumbnail generation that accepts user path
function generateThumbnail(string $source, string $destination): void
{
    if (filesize($source) > 10_000_000) {  // Triggers deserialization
        throw new \RuntimeException('File too large');
    }
    copy($source, $destination);  // Also triggers deserialization
}
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: Validate and strip stream wrappers before any file operation
final class SafePathValidator
{
    /** @var list<string> */
    private const array BLOCKED_WRAPPERS = [
        'phar://',
        'compress.zlib://',
        'compress.bzip2://',
        'zip://',
        'data://',
        'expect://',
        'php://input',
        'php://filter',
    ];

    public static function validate(string $path): string
    {
        $normalized = strtolower(trim($path));

        foreach (self::BLOCKED_WRAPPERS as $wrapper) {
            if (str_starts_with($normalized, $wrapper)) {
                throw new \InvalidArgumentException(
                    'Blocked stream wrapper: ' . $wrapper,
                );
            }
        }

        $realPath = realpath($path);
        if ($realPath === false) {
            throw new \InvalidArgumentException('Path does not resolve: ' . $path);
        }

        return $realPath;
    }
}

// SECURE: Disable phar stream wrapper globally in php.ini or at runtime
// php.ini: phar.readonly = 1 (prevents creation but does NOT prevent deserialization)
// To fully disable, unregister the wrapper:
if (in_array('phar', stream_get_wrappers(), true)) {
    stream_wrapper_unregister('phar');
}
```

#### Detection Patterns

```bash
# Literal phar:// usage in source
grep -rn 'phar://' --include="*.php" src/ Classes/

# File operations with variable paths (potential phar:// injection)
grep -rn 'file_exists\s*(\$\|is_file\s*(\$\|is_dir\s*(\$\|filesize\s*(\$' \
    --include="*.php" src/ Classes/

# Check if phar stream wrapper is unregistered anywhere
grep -rn 'stream_wrapper_unregister.*phar' --include="*.php" src/ Classes/
```

---

### 3. Server-Side Template Injection (CWE-1336)

#### Overview

Server-Side Template Injection (SSTI) occurs when user input is concatenated into
a template string rather than passed as a variable. In Twig, the `{{ variable }}`
syntax auto-escapes output, but `createTemplate()` with user input compiles and
executes arbitrary Twig code, enabling Remote Code Execution.

Attackers exploit this by injecting Twig expressions such as
`{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}`
to execute system commands.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

use Twig\Environment;
use Twig\Loader\ArrayLoader;

// VULNERABLE - DO NOT USE
// User input concatenated into template string enables RCE
function renderGreeting(Environment $twig, string $userName): string
{
    // Attacker sends: {{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
    $template = $twig->createTemplate('Hello ' . $userName);
    return $template->render([]);
}

// VULNERABLE - DO NOT USE
// Using |raw filter on user-controlled content bypasses auto-escaping
// In Twig template: {{ user_bio|raw }}
// Attacker submits bio containing Twig code

// VULNERABLE - DO NOT USE
// Blade (Laravel) - unescaped output with user input
// In Blade template: {!! $userContent !!}
// Attacker injects: @php system('id') @endphp

// VULNERABLE - DO NOT USE
// string_loader extension allows creating templates from strings
$loader = new ArrayLoader([
    'dynamic' => $_POST['template_content'],  // Attacker controls entire template
]);
$twig = new Environment($loader);
echo $twig->render('dynamic');
```

#### Secure Code

```php
<?php

declare(strict_types=1);

use Twig\Environment;
use Twig\Sandbox\SecurityPolicy;
use Twig\Extension\SandboxExtension;

// SECURE: Pass user input as a template variable, never concatenate
function renderGreeting(Environment $twig, string $userName): string
{
    // Twig auto-escapes {{ name }} -- no code execution possible
    return $twig->render('greeting.html.twig', ['name' => $userName]);
}

// SECURE: If dynamic templates are required, use Twig Sandbox
function renderDynamicTemplate(Environment $twig, string $templateContent): string
{
    $policy = new SecurityPolicy(
        allowedTags: ['if', 'for'],          // Only safe tags
        allowedFilters: ['escape', 'upper'], // Only safe filters
        allowedMethods: [],                  // No method calls
        allowedProperties: [],               // No property access
        allowedFunctions: ['range'],         // Only safe functions
    );

    $twig->addExtension(new SandboxExtension($policy, true));

    $template = $twig->createTemplate($templateContent);
    return $template->render([]);
}

// SECURE: Validate that user content does not contain template syntax
function sanitizeForTemplate(string $input): string
{
    // Strip Twig delimiters
    return str_replace(
        ['{{', '}}', '{%', '%}', '{#', '#}'],
        ['', '', '', '', '', ''],
        $input,
    );
}
```

#### Detection Patterns

```bash
# createTemplate with variable input
grep -rn 'createTemplate\s*(' --include="*.php" src/ Classes/ | grep '\$'

# |raw filter usage in Twig templates (bypasses escaping)
grep -rn '|raw' --include="*.twig" --include="*.html.twig" templates/ Resources/

# Blade unescaped output
grep -rn '{!!' --include="*.blade.php" resources/

# string_loader or ArrayLoader with user input
grep -rn 'ArrayLoader\|string_loader' --include="*.php" src/ Classes/
```

---

### 4. JWT Implementation Flaws (CWE-347)

#### Overview

JWT vulnerabilities arise from three primary implementation errors: algorithm
confusion (server expects RS256 but attacker sends HS256 token signed with the
public key as HMAC secret), the `"none"` algorithm (some libraries accept
`alg: none` to skip signature verification entirely), and missing claim validation
(no `exp`, `iss`, or `aud` checks).

Real-world CVEs include Auth0 library bypass and multiple JWT library flaws.

See also: `authentication-patterns.md` for comprehensive JWT validation patterns.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// No algorithm restriction -- attacker can switch to "none" or HS256
$decoded = JWT::decode($token, $key);

// VULNERABLE - DO NOT USE
// Accepting multiple algorithms including "none"
$decoded = JWT::decode($token, $key, ['HS256', 'RS256', 'none']);

// VULNERABLE - DO NOT USE
// Trusting the algorithm from the token header itself
$header = json_decode(base64_decode(explode('.', $token)[0]), true);
$algorithm = $header['alg'];  // Attacker-controlled
$decoded = JWT::decode($token, $key, [$algorithm]);

// VULNERABLE - DO NOT USE
// No expiration or issuer validation
$decoded = JWT::decode($token, new Key($publicKey, 'RS256'));
// Token accepted even if expired or from wrong issuer
```

#### Secure Code

```php
<?php

declare(strict_types=1);

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

// SECURE: Explicit algorithm binding via Key object
$decoded = JWT::decode($token, new Key($publicKey, 'RS256'));

// SECURE: Full claim validation
final class JwtValidator
{
    public function __construct(
        private readonly string $publicKey,
        private readonly string $expectedIssuer,
        private readonly string $expectedAudience,
    ) {}

    public function validate(string $token): object
    {
        $decoded = JWT::decode(
            $token,
            new Key($this->publicKey, 'RS256'),
        );

        if (!isset($decoded->iss) || $decoded->iss !== $this->expectedIssuer) {
            throw new \UnexpectedValueException('Invalid issuer');
        }

        if (!isset($decoded->aud) || $decoded->aud !== $this->expectedAudience) {
            throw new \UnexpectedValueException('Invalid audience');
        }

        if (!isset($decoded->exp) || $decoded->exp < time()) {
            throw new \UnexpectedValueException('Token expired');
        }

        return $decoded;
    }
}
```

#### Detection Patterns

```bash
# JWT decode without Key object (old API, no algorithm pinning)
grep -rn 'JWT::decode\s*(' --include="*.php" src/ Classes/ | grep -v 'new Key'

# "none" algorithm in allowed list
grep -rn "'none'" --include="*.php" src/ Classes/ | grep -i 'jwt\|alg\|algorithm'

# Manual JWT parsing without library validation
grep -rn 'base64_decode.*explode.*\.' --include="*.php" src/ Classes/
```

---

## High Priority

### 5. Email Header Injection (CWE-93)

#### Overview

PHP's `mail()` function passes headers directly to the system MTA. If user input
containing `\r\n` (CRLF) is included in header values, an attacker can inject
arbitrary headers such as `Bcc:`, `Cc:`, or even inject a second email body.
This enables spam relay through the application.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// Attacker sends: evil@test.com\r\nBcc: victim1@x.com,victim2@x.com
$from = $_POST['email'];
mail($to, $subject, $body, "From: " . $from);

// VULNERABLE - DO NOT USE
// Subject header injection
$subject = $_POST['subject'];  // Attacker: "Test\r\nBcc: spam@attacker.com"
mail($to, $subject, $body);
```

#### Secure Code

```php
<?php

declare(strict_types=1);

use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Mime\Email;

// SECURE: Use Symfony Mailer -- it sanitizes all headers
function sendContactEmail(MailerInterface $mailer, string $fromAddress, string $message): void
{
    // Symfony Mailer validates email addresses and strips CRLF from headers
    $email = (new Email())
        ->from('noreply@example.com')
        ->replyTo($fromAddress)  // Safe: validated and sanitized
        ->to('contact@example.com')
        ->subject('Contact Form Submission')
        ->text($message);

    $mailer->send($email);
}

// SECURE: Manual sanitization when mail() cannot be replaced
function sanitizeHeaderValue(string $value): string
{
    // Remove all CR and LF characters
    return str_replace(["\r", "\n", "\0"], '', $value);
}

// SECURE: Validate email format before use in headers
function isValidEmail(string $email): bool
{
    return filter_var($email, FILTER_VALIDATE_EMAIL) !== false
        && !preg_match('/[\r\n]/', $email);
}
```

#### Detection Patterns

```bash
# mail() with superglobal input
grep -rn 'mail\s*(' --include="*.php" src/ Classes/ | grep '\$_'

# mail() with variable From/Cc/Bcc headers
grep -rn 'mail\s*(' --include="*.php" src/ Classes/ | grep -i 'from\|cc\|bcc'
```

---

### 6. LDAP Injection (CWE-90)

#### Overview

LDAP filter expressions use metacharacters `*`, `(`, `)`, `\`, and NUL bytes.
When user input is concatenated into LDAP filter strings, an attacker can modify
the query logic. For example, injecting `admin)(|(uid=*` into a filter like
`(&(uid=$user)(password=$pass))` produces
`(&(uid=admin)(|(uid=*)(password=$pass))` which matches any user.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// String concatenation in LDAP filter
function ldapLogin(string $username, string $password): bool
{
    $ds = ldap_connect('ldap://ldap.example.com');
    $filter = "(&(uid=" . $username . ")(userPassword=" . $password . "))";
    $result = ldap_search($ds, 'dc=example,dc=com', $filter);
    return ldap_count_entries($ds, $result) > 0;
}

// VULNERABLE - DO NOT USE
// Even with bind authentication, unescaped DN is dangerous
function ldapBind(string $username): bool
{
    $ds = ldap_connect('ldap://ldap.example.com');
    // Attacker: admin,ou=admins,dc=example,dc=com
    $dn = "uid=" . $username . ",ou=users,dc=example,dc=com";
    return @ldap_bind($ds, $dn, $_POST['password']);
}
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: Use ldap_escape() for filter values (PHP 5.6+)
function ldapLoginSafe(string $username, string $password): bool
{
    $ds = ldap_connect('ldap://ldap.example.com');

    // ldap_escape with LDAP_ESCAPE_FILTER escapes *, (, ), \, NUL
    $safeUser = ldap_escape($username, '', LDAP_ESCAPE_FILTER);
    $filter = "(&(uid=" . $safeUser . ")(objectClass=inetOrgPerson))";

    $result = ldap_search($ds, 'dc=example,dc=com', $filter);
    $entries = ldap_get_entries($ds, $result);

    if ($entries['count'] !== 1) {
        return false;
    }

    // Authenticate via LDAP bind with the found DN
    $userDn = $entries[0]['dn'];
    return @ldap_bind($ds, $userDn, $password);
}

// SECURE: Use ldap_escape with LDAP_ESCAPE_DN for DN values
function buildUserDn(string $username): string
{
    $safeName = ldap_escape($username, '', LDAP_ESCAPE_DN);
    return "uid=" . $safeName . ",ou=users,dc=example,dc=com";
}
```

#### Detection Patterns

```bash
# LDAP functions with superglobal or variable concatenation
grep -rn 'ldap_search\s*.*\$_\|ldap_search\s*.*\$.*\.' --include="*.php" src/ Classes/
grep -rn 'ldap_bind\s*.*\$_' --include="*.php" src/ Classes/

# Check for ldap_escape usage (should be present near ldap_search)
grep -rn 'ldap_escape' --include="*.php" src/ Classes/
```

---

### 7. Insecure Token Generation (CWE-330)

#### Overview

Tokens generated with predictable functions like `md5(time())`, `sha1(uniqid())`,
or `substr(md5(rand()), 0, 16)` have insufficient entropy and are trivially
brute-forced. The `time()` function has second-level granularity (only ~86400
values per day), `uniqid()` is based on microsecond timestamp (predictable),
and `rand()` / `mt_rand()` use a seedable PRNG.

Real-world CVEs include WordPress password reset token prediction.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// time() has only 86400 values per day -- trivially brute-forced
$token = md5(time() . $userId);

// VULNERABLE - DO NOT USE
// uniqid() is based on microtime -- predictable with server time knowledge
$token = sha1(uniqid('', true));

// VULNERABLE - DO NOT USE
// mt_rand() is a deterministic PRNG -- can be predicted after ~624 outputs
$token = substr(md5((string) mt_rand()), 0, 16);

// VULNERABLE - DO NOT USE
// Combining weak sources does not increase unpredictability
$token = md5(microtime() . mt_rand() . $userId);

// VULNERABLE - DO NOT USE
// array_rand + shuffled charset -- entropy depends on mt_rand() seed
$chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
$token = '';
for ($i = 0; $i < 32; $i++) {
    $token .= $chars[mt_rand(0, strlen($chars) - 1)];
}
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: random_bytes() uses OS CSPRNG (/dev/urandom or equivalent)
// 32 bytes = 256 bits of entropy -- infeasible to brute-force
$token = bin2hex(random_bytes(32));

// SECURE: For URL-safe tokens
$token = rtrim(strtr(base64_encode(random_bytes(32)), '+/', '-_'), '=');

// SECURE: For numeric OTP codes (e.g., email verification)
$otp = random_int(100000, 999999);

// SECURE: Using Symfony's token generator
// Symfony's CsrfTokenManager and UuidV4 both use random_bytes() internally
use Symfony\Component\Uid\Uuid;
$token = Uuid::v4()->toRfc4122();
```

#### Detection Patterns

```bash
# Predictable token generation functions
grep -rn 'md5\s*(time\|md5\s*(microtime\|md5\s*(rand\|md5\s*(mt_rand' \
    --include="*.php" src/ Classes/
grep -rn 'sha1\s*(uniqid\|sha1\s*(time\|sha1\s*(rand' \
    --include="*.php" src/ Classes/
grep -rn 'uniqid\s*(' --include="*.php" src/ Classes/
grep -rn 'mt_rand\|rand\s*(' --include="*.php" src/ Classes/ | grep -i 'token\|secret\|key\|salt\|nonce'

# Verify random_bytes/random_int usage for security-critical generation
grep -rn 'random_bytes\|random_int' --include="*.php" src/ Classes/
```

---

### 8. HTTP Host Header Poisoning (CWE-644)

#### Overview

When an application uses `$_SERVER['HTTP_HOST']` or `$_SERVER['SERVER_NAME']`
to construct URLs in security-critical contexts (password reset links, OAuth
callbacks, canonical URLs), an attacker can send a crafted `Host:` header to
redirect those links to a malicious domain. The victim receives a legitimate
password reset email but the link points to the attacker's server, leaking the
reset token.

Real-world CVEs include Drupal password reset host header attacks and WordPress
host header injection.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// Host header is attacker-controlled
$resetUrl = 'https://' . $_SERVER['HTTP_HOST'] . '/reset?token=' . $token;
sendResetEmail($userEmail, $resetUrl);

// VULNERABLE - DO NOT USE
// Cache poisoning via Host header in canonical URL
$canonicalUrl = 'https://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
header('Link: <' . $canonicalUrl . '>; rel="canonical"');

// VULNERABLE - DO NOT USE
// OAuth callback URL constructed from Host header
$callbackUrl = 'https://' . $_SERVER['HTTP_HOST'] . '/oauth/callback';
$authUrl = $oauthProvider->getAuthorizationUrl(['redirect_uri' => $callbackUrl]);
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: Use application configuration for base URL
final class UrlGenerator
{
    public function __construct(
        private readonly string $baseUrl,  // From environment config, e.g., APP_URL
    ) {}

    public function generateResetUrl(string $token): string
    {
        return $this->baseUrl . '/reset?token=' . urlencode($token);
    }

    public function generateCallbackUrl(string $path): string
    {
        return $this->baseUrl . '/' . ltrim($path, '/');
    }
}

// SECURE: Validate Host header against allowlist if it must be used
function validateHostHeader(): string
{
    $allowedHosts = ['www.example.com', 'example.com'];
    $host = $_SERVER['HTTP_HOST'] ?? '';

    // Strip port number for comparison
    $hostWithoutPort = strtolower(explode(':', $host)[0]);

    if (!in_array($hostWithoutPort, $allowedHosts, true)) {
        http_response_code(400);
        exit('Invalid host header');
    }

    return $host;
}
```

#### Framework Patterns

- **Symfony**: Use `UrlGeneratorInterface` which constructs URLs from configured `router.request_context.host`
- **Laravel**: Use `config('app.url')` or `url()` helper which reads from `APP_URL` environment variable
- **TYPO3**: Use `GeneralUtility::getIndpEnv('TYPO3_REQUEST_HOST')` which validates against `$GLOBALS['TYPO3_CONF_VARS']['SYS']['trustedHostsPattern']`

#### Detection Patterns

```bash
# HTTP_HOST in URL construction
grep -rn 'HTTP_HOST' --include="*.php" src/ Classes/ | grep -i 'url\|link\|href\|redirect\|reset'

# SERVER_NAME in URL construction (also attacker-influenced on some configurations)
grep -rn 'SERVER_NAME' --include="*.php" src/ Classes/ | grep -i 'url\|link\|href'
```

---

### 9. Log Injection / CRLF Injection (CWE-117)

#### Overview

When user input is written to log files without sanitization, an attacker can
inject newline characters to forge log entries. The payload
`admin\nLogin successful for user: admin` creates a fake success entry.
Beyond log forgery, this can trigger false alerts in SIEM systems, exploit
XSS in web-based log viewers, and corrupt log integrity for forensic analysis.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// User input directly in log message allows log forging
error_log("Login failed for user: " . $_POST['username']);

// VULNERABLE - DO NOT USE
// PSR-3 logger with unsanitized interpolation
$logger->warning("Access denied for {user} from {ip}", [
    'user' => $_POST['username'],  // Contains \r\n
    'ip' => $_SERVER['REMOTE_ADDR'],
]);

// VULNERABLE - DO NOT USE
// File-based logging with concatenation
file_put_contents(
    '/var/log/app.log',
    date('Y-m-d H:i:s') . " Login attempt: " . $_POST['username'] . "\n",
    FILE_APPEND,
);
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: Sanitize log input by replacing control characters
function sanitizeForLog(string $input): string
{
    // Replace CR, LF, TAB, and other control characters
    return preg_replace('/[\x00-\x1F\x7F]/', '_', $input);
}

error_log("Login failed for user: " . sanitizeForLog($_POST['username']));

// SECURE: Use structured (JSON) logging -- newlines in values are escaped
$logger->warning('Access denied', [
    'user' => $_POST['username'],  // JSON encoding escapes \r\n
    'ip' => $_SERVER['REMOTE_ADDR'],
    'timestamp' => time(),
]);
// Output: {"message":"Access denied","context":{"user":"admin\\nfake","ip":"1.2.3.4"}}

// SECURE: Monolog with JSON formatter
use Monolog\Logger;
use Monolog\Handler\StreamHandler;
use Monolog\Formatter\JsonFormatter;

$handler = new StreamHandler('/var/log/app.log');
$handler->setFormatter(new JsonFormatter());
$logger = new Logger('security');
$logger->pushHandler($handler);
```

#### Detection Patterns

```bash
# error_log with superglobals
grep -rn 'error_log\s*(.*\$_' --include="*.php" src/ Classes/

# Logger methods with unsanitized variables
grep -rn '->log\|->warning\|->error\|->info' --include="*.php" src/ Classes/ | grep '\$_'

# file_put_contents to log files with user input
grep -rn 'file_put_contents.*log.*\$_' --include="*.php" src/ Classes/
```

---

### 10. Session Fixation (CWE-384)

#### Overview

Session fixation occurs when an attacker sets a known session ID for a victim
before the victim authenticates. After authentication, the attacker uses the
pre-set session ID to access the authenticated session. This is possible when
the application accepts session IDs from URL parameters, does not regenerate
session IDs after login, or when `session.use_strict_mode` is disabled.

See also: `authentication-patterns.md` for complete session security coverage.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// Accepting session ID from URL parameter
session_id($_GET['sid']);  // Attacker sends link: https://app.com/login?sid=known-id
session_start();

// VULNERABLE - DO NOT USE
// No session regeneration after authentication
function login(string $username, string $password): bool
{
    if (authenticate($username, $password)) {
        $_SESSION['authenticated'] = true;
        $_SESSION['user'] = $username;
        // Session ID remains the same -- fixation possible
        return true;
    }
    return false;
}
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: Regenerate session ID after authentication state change
function loginSecure(string $username, string $password): bool
{
    if (!authenticate($username, $password)) {
        return false;
    }

    // Destroy old session and create new one
    // true parameter deletes the old session file
    session_regenerate_id(true);

    $_SESSION['authenticated'] = true;
    $_SESSION['user'] = $username;
    $_SESSION['created_at'] = time();

    return true;
}

// SECURE: Configure strict session mode
ini_set('session.use_strict_mode', '1');       // Reject uninitialized session IDs
ini_set('session.use_only_cookies', '1');       // No session ID in URL
ini_set('session.use_trans_sid', '0');          // No transparent session ID
ini_set('session.cookie_httponly', '1');         // No JavaScript access
ini_set('session.cookie_secure', '1');          // HTTPS only
ini_set('session.cookie_samesite', 'Lax');      // CSRF protection
session_start();
```

#### Detection Patterns

```bash
# session_id() with user input
grep -rn 'session_id\s*(\$_' --include="*.php" src/ Classes/

# session_start without nearby session_regenerate_id
grep -rn 'session_start\|session_regenerate_id' --include="*.php" src/ Classes/

# Disabled strict mode
grep -rn 'use_strict_mode.*0\|use_only_cookies.*0\|use_trans_sid.*1' \
    --include="*.php" --include="*.ini" .
```

---

## Medium Priority

### 11. Timing Attacks on Authentication (CWE-208)

#### Overview

Standard string comparison operators (`===`, `strcmp()`) return early on the
first mismatched byte, leaking timing information. An attacker measuring response
times across many requests can determine the correct value one byte at a time.
This is practical for tokens, API keys, and HMAC signatures where the attacker
can make repeated requests.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// Strict comparison is NOT timing-safe -- returns false at first mismatched byte
function verifyApiKey(string $submitted, string $stored): bool
{
    return $submitted === $stored;
}

// VULNERABLE - DO NOT USE
// strcmp leaks timing info and has type juggling issues
function verifyToken(string $submitted, string $stored): bool
{
    return strcmp($submitted, $stored) === 0;
}

// VULNERABLE - DO NOT USE
// HMAC comparison with === leaks timing info about the hash
function verifyWebhookSignature(string $payload, string $signature, string $secret): bool
{
    $expected = hash_hmac('sha256', $payload, $secret);
    return $expected === $signature;
}
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: hash_equals() compares all bytes regardless of where first mismatch occurs
function verifyApiKey(string $submitted, string $stored): bool
{
    return hash_equals($stored, $submitted);
}

// SECURE: HMAC verification with constant-time comparison
function verifyWebhookSignature(string $payload, string $signature, string $secret): bool
{
    $expected = hash_hmac('sha256', $payload, $secret);
    return hash_equals($expected, $signature);
}

// SECURE: For password verification, password_verify() is already timing-safe
function verifyPassword(string $submitted, string $storedHash): bool
{
    return password_verify($submitted, $storedHash);
}
```

#### Detection Patterns

```bash
# Direct comparison of tokens, hashes, signatures, API keys
grep -rn '===.*\$.*token\|===.*\$.*hash\|===.*\$.*hmac\|===.*\$.*signature\|===.*\$.*api.key' \
    --include="*.php" src/ Classes/
grep -rn 'strcmp\s*(.*token\|strcmp\s*(.*hash' --include="*.php" src/ Classes/

# Verify hash_equals is used
grep -rn 'hash_equals' --include="*.php" src/ Classes/
```

---

### 12. Second-Order SQL Injection (CWE-89)

#### Overview

Second-order SQL injection occurs when data is stored safely using parameterized
queries but later retrieved and used unsafely in a dynamic query. The initial
INSERT is safe, but a subsequent SELECT or UPDATE concatenates the stored value
directly into SQL. This is harder to detect because the injection point and the
exploitation point are in different code paths.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// Step 1: Data stored safely via parameterized query
// User registers with username: admin'--
$stmt = $pdo->prepare('INSERT INTO users (username, email) VALUES (?, ?)');
$stmt->execute([$_POST['username'], $_POST['email']]);  // Safe storage

// Step 2: Data retrieved and used unsafely in another query
// VULNERABLE - DO NOT USE
function getUserPosts(PDO $pdo, int $userId): array
{
    // Fetch the stored username
    $stmt = $pdo->prepare('SELECT username FROM users WHERE id = ?');
    $stmt->execute([$userId]);
    $user = $stmt->fetch();

    // Concatenate stored value into SQL -- second-order injection
    $query = "SELECT * FROM posts WHERE author = '" . $user['username'] . "'";
    return $pdo->query($query)->fetchAll();
    // If username is: admin'-- the query becomes:
    // SELECT * FROM posts WHERE author = 'admin'--'
}
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: Always use parameterized queries, even for data from your own database
function getUserPosts(PDO $pdo, int $userId): array
{
    $stmt = $pdo->prepare('SELECT username FROM users WHERE id = ?');
    $stmt->execute([$userId]);
    $user = $stmt->fetch();

    // Parameterized even though data comes from the database
    $stmt = $pdo->prepare('SELECT * FROM posts WHERE author = ?');
    $stmt->execute([$user['username']]);
    return $stmt->fetchAll();
}

// SECURE: Doctrine DQL also uses parameterized queries
// $qb->select('p')
//    ->from(Post::class, 'p')
//    ->where('p.author = :author')
//    ->setParameter('author', $user->getUsername());
```

#### Detection Patterns

This pattern requires data flow analysis across multiple code paths and is best
detected through manual LLM-assisted code review. Look for:

1. Values fetched from the database via `->fetch()`, `->fetchColumn()`, etc.
2. Those values concatenated into subsequent SQL strings
3. String interpolation or concatenation in SQL near `$row[`, `$user->`, `$result[`

```bash
# Look for SQL string concatenation patterns (potential second-order)
grep -rn "SELECT.*FROM.*'.*\\..*\$\|WHERE.*'.*\\..*\$" --include="*.php" src/ Classes/
grep -rn '->query\s*(' --include="*.php" src/ Classes/ | grep '\$'
```

---

### 13. ReDoS -- Regular Expression Denial of Service (CWE-1333)

#### Overview

Catastrophic backtracking occurs when a regex engine encounters nested quantifiers
or overlapping alternation with crafted input. Patterns like `(a+)+`, `(a|a)+`,
or `(.*)+` cause exponential time complexity. An input of just 30 characters can
take minutes to evaluate, causing denial of service.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// Nested quantifiers cause exponential backtracking
$pattern = '/^(a+)+$/';
preg_match($pattern, str_repeat('a', 30) . 'X');  // Takes exponential time

// VULNERABLE - DO NOT USE
// Overlapping alternation with quantifier
$pattern = '/^([a-zA-Z0-9]+)*@/';
preg_match($pattern, str_repeat('a', 30) . '!');  // Catastrophic backtracking

// VULNERABLE - DO NOT USE
// Email validation with dangerous pattern
$pattern = '/^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|'
    . '(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$/';
preg_match($pattern, $userInput);

// VULNERABLE - DO NOT USE
// URL validation with nested groups
$pattern = '/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/';
preg_match($pattern, $userInput);
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: Use possessive quantifiers to prevent backtracking
$pattern = '/^[a-zA-Z0-9]++$/';  // ++ is possessive, no backtracking

// SECURE: Use atomic groups
$pattern = '/^(?>[a-zA-Z0-9]+)$/';  // Atomic group, no backtracking

// SECURE: Set PCRE backtrack limit as defense-in-depth
ini_set('pcre.backtrack_limit', '10000');  // Default is 1000000

// SECURE: Use built-in validation functions instead of regex
function validateEmail(string $email): bool
{
    return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
}

function validateUrl(string $url): bool
{
    return filter_var($url, FILTER_VALIDATE_URL) !== false;
}

// SECURE: Limit input length before regex matching
function safeRegexMatch(string $pattern, string $input, int $maxLength = 1000): bool
{
    if (strlen($input) > $maxLength) {
        return false;
    }

    $result = preg_match($pattern, $input);

    if ($result === false) {
        // PREG_BACKTRACK_LIMIT_ERROR or other regex error
        return false;
    }

    return $result === 1;
}
```

#### Detection Patterns

```bash
# Nested quantifiers (primary ReDoS indicator)
grep -rn '(\.\*)\+\|(\.+)\+\|(\[^"]\*)\*' --include="*.php" src/ Classes/

# Regex patterns applied to user input
grep -rn 'preg_match\s*(.*\$_\|preg_replace\s*(.*\$_' --include="*.php" src/ Classes/

# preg_match without return value check (misses PCRE errors)
grep -rn 'preg_match\s*(' --include="*.php" src/ Classes/ | grep -v 'if\|==='
```

---

### 14. Privilege Escalation via Parameter Manipulation (CWE-269)

#### Overview

Privilege escalation through parameter manipulation occurs when an application
checks only that a user IS authenticated but not that they have the correct role
or permission for a specific action. Attackers modify hidden form fields, API
parameters, or URL paths to access resources or perform actions beyond their
authorization level.

#### Vulnerable Code

```php
<?php

declare(strict_types=1);

// VULNERABLE - DO NOT USE
// Only checks authentication, not authorization for admin action
function deleteUser(int $targetUserId): void
{
    if (!isAuthenticated()) {
        throw new \RuntimeException('Not logged in');
    }
    // Missing: isAdmin() or hasPermission('user.delete') check
    $this->userRepository->delete($targetUserId);
}

// VULNERABLE - DO NOT USE
// Role from POST data -- attacker changes role=admin in request
function updateProfile(array $data): void
{
    $user = getCurrentUser();
    $user->setName($data['name']);
    $user->setEmail($data['email']);
    $user->setRole($data['role']);  // Attacker controls this
    $this->userRepository->save($user);
}

// VULNERABLE - DO NOT USE
// IDOR: no ownership check
function viewDocument(int $documentId): Document
{
    // Any authenticated user can view any document by changing the ID
    return $this->documentRepository->find($documentId);
}
```

#### Secure Code

```php
<?php

declare(strict_types=1);

// SECURE: Check both authentication and authorization
function deleteUser(int $targetUserId): void
{
    $currentUser = getCurrentAuthenticatedUser();

    if (!$currentUser->hasPermission('user.delete')) {
        throw new AccessDeniedException('Insufficient privileges');
    }

    $this->userRepository->delete($targetUserId);
    $this->auditLogger->log('user.deleted', [
        'actor' => $currentUser->getId(),
        'target' => $targetUserId,
    ]);
}

// SECURE: Never accept role/permission from user input
function updateProfile(array $data): void
{
    $user = getCurrentAuthenticatedUser();
    $allowed = ['name', 'email', 'timezone'];  // Allowlist

    foreach ($allowed as $field) {
        if (isset($data[$field])) {
            $setter = 'set' . ucfirst($field);
            $user->$setter($data[$field]);
        }
    }
    // role, permissions, isAdmin are never settable from user input
    $this->userRepository->save($user);
}

// SECURE: Ownership check (prevents IDOR)
function viewDocument(int $documentId): Document
{
    $currentUser = getCurrentAuthenticatedUser();
    $document = $this->documentRepository->find($documentId);

    if ($document->getOwnerId() !== $currentUser->getId()
        && !$currentUser->hasPermission('document.view.all')
    ) {
        throw new AccessDeniedException('Not authorized to view this document');
    }

    return $document;
}
```

#### Detection Patterns

This pattern primarily requires LLM-assisted review to understand the authorization
architecture. Grep can identify candidate locations:

```bash
# Controller actions without authorization checks
grep -rn 'function.*Action\s*(' --include="*.php" src/ Classes/ | head -50
# Then manually verify each has authorization logic

# Role/permission set from request data
grep -rn 'setRole\|setPermission\|setAdmin\|is_admin' --include="*.php" src/ Classes/ \
    | grep '\$_\|request\|input'

# Missing ownership checks in repository queries
grep -rn '->find\s*(\$\|->findOneBy' --include="*.php" src/ Classes/
```

---

### 15. Mass Assignment (CWE-915)

#### Overview

Mass assignment occurs when user input is bound directly to model properties
without filtering, allowing attackers to set fields like `is_admin`, `role`,
or `price` that should not be user-settable.

For comprehensive coverage including framework-specific patterns for Laravel
(`$fillable`/`$guarded`), Symfony Forms, and TYPO3 trusted properties, see
`modern-attacks.md`.

#### Key Detection Checkpoints

```php
<?php

declare(strict_types=1);

// CRITICAL: Laravel -- empty $guarded disables all mass assignment protection
// protected $guarded = [];

// CRITICAL: TYPO3 Extbase -- allowAllProperties() disables trusted properties
// $this->arguments['user']->getPropertyMappingConfiguration()->allowAllProperties();

// CRITICAL: Direct hydration from superglobals
// foreach ($_POST as $key => $value) { $entity->$key = $value; }
```

#### Detection Patterns

```bash
# Laravel: empty guarded array
grep -rn 'guarded\s*=\s*\[\s*\]' --include="*.php" src/ app/

# TYPO3: disabled trusted properties
grep -rn 'allowAllProperties' --include="*.php" Classes/

# Generic: array_merge with superglobals
grep -rn 'array_merge\s*(.*\$_POST\|array_merge\s*(.*\$_REQUEST' --include="*.php" src/ Classes/

# Generic: extract() on user input
grep -rn 'extract\s*(\$_' --include="*.php" src/ Classes/

# Laravel: fill with all request data
grep -rn '->fill\s*(\$request->all' --include="*.php" src/ app/
```

---

## Detection Pattern Summary

The following table maps each vulnerability to its primary grep-based detection
patterns for use in automated security scanning.

| # | Vulnerability | CWE | Primary Detection Pattern |
|---|--------------|-----|--------------------------|
| 1 | Type Juggling | CWE-843 | `==\s*\$_` in auth code |
| 2 | PHAR Deserialization | CWE-502 | `phar://` literal; `file_exists(\$` with user paths |
| 3 | Template Injection | CWE-1336 | `createTemplate.*\$`; `\|raw` in templates |
| 4 | JWT Flaws | CWE-347 | `JWT::decode` without `new Key`; `'none'` algorithm |
| 5 | Email Header Injection | CWE-93 | `mail\s*(\.\*\$_` |
| 6 | LDAP Injection | CWE-90 | `ldap_search.*\$_`; absence of `ldap_escape` |
| 7 | Insecure Tokens | CWE-330 | `md5(time`; `sha1(uniqid`; `md5(rand` |
| 8 | Host Header Poisoning | CWE-644 | `HTTP_HOST` in URL construction |
| 9 | Log Injection | CWE-117 | `error_log.*\$_`; `->log.*\$_` |
| 10 | Session Fixation | CWE-384 | `session_id(\$_`; missing `session_regenerate_id` |
| 11 | Timing Attacks | CWE-208 | `===` on token/hash variables; absence of `hash_equals` |
| 12 | Second-Order SQLi | CWE-89 | `->query(\$` with data from `->fetch` (manual review) |
| 13 | ReDoS | CWE-1333 | Nested quantifiers `(.*)+`; `(.+)+` |
| 14 | Privilege Escalation | CWE-269 | `setRole.*\$_`; actions without permission checks (manual review) |
| 15 | Mass Assignment | CWE-915 | `$guarded = []`; `allowAllProperties()`; `extract(\$_` |

---

## Remediation Priority

| Severity | Finding | CWE | Timeline |
|----------|---------|-----|----------|
| Critical | Type juggling in authentication | CWE-843 | Immediate |
| Critical | PHAR deserialization via file operations | CWE-502 | Immediate |
| Critical | Server-side template injection | CWE-1336 | Immediate |
| Critical | JWT algorithm confusion / "none" algorithm | CWE-347 | Immediate |
| High | Email header injection via mail() | CWE-93 | 24 hours |
| High | LDAP injection in filter strings | CWE-90 | 24 hours |
| High | Predictable token generation | CWE-330 | 24 hours |
| High | Host header poisoning in reset links | CWE-644 | 48 hours |
| High | Log injection / CRLF injection | CWE-117 | 48 hours |
| High | Session fixation (no regeneration) | CWE-384 | 48 hours |
| Medium | Timing attacks on token comparison | CWE-208 | 1 week |
| Medium | Second-order SQL injection | CWE-89 | 1 week |
| Medium | ReDoS via nested quantifiers | CWE-1333 | 1 week |
| Medium | Privilege escalation via parameter manipulation | CWE-269 | 1 week |
| Medium | Mass assignment (unprotected properties) | CWE-915 | 1 week |

---

## Related References

- `authentication-patterns.md` -- JWT validation, session security, timing-safe comparison
- `deserialization-prevention.md` -- phar:// attacks, unserialize() safety, gadget chains
- `modern-attacks.md` -- Mass assignment (detailed), SSRF, race conditions
- `input-validation.md` -- Input sanitization and validation patterns
- `owasp-top10.md` -- OWASP Top 10 mapping for these vulnerability classes
- `cwe-top25.md` -- CWE Top 25 cross-reference
- `security-logging.md` -- Structured logging to prevent log injection
- OWASP Testing Guide: https://owasp.org/www-project-web-security-testing-guide/
- PHP Security Best Practices: https://www.php.net/manual/en/security.php
- CWE Database: https://cwe.mitre.org/
